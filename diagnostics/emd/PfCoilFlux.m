function [fluxPF,Bt,Br]=PfCoilFlux(coilname,fig)
if nargin<2
    fig=1;
end
% PF coil parameter
probe_xgrid=9;
probe_ygrid=9;
currentFile = mfilename('fullpath');
folderpath=[currentFile(1:end-10),'data\'];
filepath=[folderpath,'EXL50UProbeFluxLoop.xlsx'];
CoilParameter=readtable(filepath,'Sheet','coils','VariableNamingRule','preserve');
FluxParameter=readtable(filepath,'Sheet','flux','VariableNamingRule','preserve',Range='A1:D48');
MBTParameter=readtable(filepath,'Sheet','probeBt','VariableNamingRule','preserve',Range='A1:I53');
MBrParameter=readtable(filepath,'Sheet','probeBr','VariableNamingRule','preserve');

%------------------------------------------------------------------------------
[X2,Y2,FilamentCurrent,GapX]=sourcePrepare(CoilParameter,coilname);%单个线圈网格化后的一维数据点

[bt_x,bt_y]=getProbePoint(MBTParameter, probe_xgrid, probe_ygrid); % 探针位置网格化 X-10   y-10
[br_x,br_y]=getProbePoint(MBrParameter, probe_xgrid, probe_ygrid); % 探针位置网格化 X-10   y-10
%------------------compute the flux generated by PF coil--------------------------------------------------------------

FluxPositon.X=table2array(FluxParameter(:,2))/1e3;
FluxPositon.Y=table2array(FluxParameter(:,3))/1e3;
fluxPF=MMutInductance(FluxPositon.X,FluxPositon.Y,X2,Y2,FilamentCurrent,GapX);
%---------------compute the B_theta--------------------------------
[BX,BY]=MMagneticField(bt_x,bt_y,X2,Y2,FilamentCurrent);
BX2=reshape(BX,[(probe_xgrid*probe_ygrid),numel(BX)/(probe_xgrid*probe_ygrid)]);
BY2=reshape(BY,[(probe_xgrid*probe_ygrid),numel(BY)/(probe_xgrid*probe_ygrid)]);
B_X=sum(BX2,1)/(probe_xgrid*probe_ygrid)*1e4;
B_Y=sum(BY2,1)/(probe_xgrid*probe_ygrid)*1e4;
theta_bt=table2array(MBTParameter(:,4))/180*pi;
Bt=-B_X.*cos(theta_bt')-B_Y.*sin(theta_bt');  % PF contribution
%-------------compute the B-r-------------------------------------------
[BX,BY]=MMagneticField(br_x,br_y,X2,Y2,FilamentCurrent);
BX2=reshape(BX,[(probe_xgrid*probe_ygrid),numel(BX)/(probe_xgrid*probe_ygrid)]);
BY2=reshape(BY,[(probe_xgrid*probe_ygrid),numel(BY)/(probe_xgrid*probe_ygrid)]);
B_X=sum(BX2,1)/(probe_xgrid*probe_ygrid)*1e4;
B_Y=sum(BY2,1)/(probe_xgrid*probe_ygrid)*1e4;
theta_br=table2array(MBrParameter(:,4))/180*pi;
Br=B_Y.*cos(theta_br')-B_X.*sin(theta_br'); % PF contribution
if fig
    figure;stackplot({{1:numel(fluxPF),fluxPF*1e3,'mWb'}},coilname,'Flux',1)
    figure;stackplot({{1:numel(Bt),Bt*1e4,'B_theta(mGauss)'}},coilname,'poloidal B field',1)
    figure;stackplot({{1:numel(Br),Br*1e4,'Br(mGauss)'}},coilname,'radial B field',1)
end

    function [X2,Y2,FilamentCurrent,GapX]=sourcePrepare(coilParam,CoilName)
        rowNames=coilParam(:,1);
        rowIndex = ismember(rowNames.Variables, upper(CoilName));
        selectedRows = coilParam(rowIndex, :);
        XCenter=table2array(selectedRows(1,2));
        YCenter=table2array(selectedRows(1,3));
        W=table2array(selectedRows(1,4));
        H=table2array(selectedRows(1,5));
        NX=table2array(selectedRows(1,6));
        NY=table2array(selectedRows(1,7));
        N=table2array(selectedRows(1,8));
        Angle=table2array(selectedRows(1,9));


        % 考虑到线圈实际绕制，实际匝数N=Nx*Ny-2； 线圈电流均匀化
        AmperTurn = ones(1, NX * NY) * N/ (NX * NY);
        % 计算在X和Y方向上的步长
        StepX = W / NX/ 2;
        StepY = H / NY / 2;
        % 定义gapX，考虑到因子、NX、NY和步长
        factor = 0.23; % 调节因子
        GapX = ones(1, NX * NY) * 2 * StepX * factor;


        % 生成源点的网格坐标，考虑倾斜调整
        [X2, Y2] = meshgrid(-W/2 + StepX : 2 * StepX : W/2 - StepX, ...
            -H/2 + StepY : 2 * StepY : H/2 - StepY);

        % 应用倾斜角度调整和中心位置调整
        X2 = X2 + Y2 .* cot(Angle * pi / 180) + XCenter;
        Y2 = Y2 + YCenter;

        % 重塑源点坐标和安匝数数组为一维数组，以便进行计算
        numElements = numel(X2);
        X2 = reshape(X2, 1, numElements);
        Y2 = reshape(Y2, 1, numElements);
        FilamentCurrent = reshape(AmperTurn, 1, numElements);

    end
    function [XX,YY]=getProbePoint(probeParam, Nx, Ny)
        % 根据中心点、宽度、高度、倾斜角度、以及Nx和Ny生成探测点坐标
        % 输入:
        % XCenter, YCenter - 线圈中心点坐标
        % W, H - 线圈的宽度和高度
        % Angle - 线圈的倾斜角度，单位为度
        % Nx, Ny - 网格点的数量，应为奇数
        % 将输入参数转换为行向量，以便进行批处理操作
        %getProbePoint(XCenter, YCenter, W, H, Angle, Nx, Ny)

        XCenter=table2array(probeParam(:,2))/1e3;
        YCenter=table2array(probeParam(:,3))/1e3;
        Angle=table2array(probeParam(:,4));
        W=table2array(probeParam(:,6))/1e3;
        H=table2array(probeParam(:,7))/1e3;
        %转变为列向量
        Numcoils=numel(XCenter);
        XCenter=reshape(XCenter,[1 Numcoils]);
        YCenter=reshape(YCenter,[1 Numcoils]);
        W=reshape(W,[1 Numcoils]);
        H=reshape(H,[1 Numcoils]);
        Angle=reshape(Angle,[1 Numcoils]);
        theta = Angle * pi / 180;
        % 生成x和y方向的向量，确保中心点为(0,0)
        xVec = (-(Nx - 1):2:(Nx - 1)) / (2 * Nx);
        yVec = ((Ny - 1):-2:-(Ny - 1)) / (2 * Ny);
        % 生成网格点，表示探测点的相对位置
        [X1, Y1] = meshgrid(xVec, yVec);
        % 将网格点扁平化为列向量
        gridNum = numel(X1);
        X1 = reshape(X1, [gridNum, 1]);
        Y1 = reshape(Y1, [gridNum, 1]);

        % 对每个线圈重复网格点，准备应用变换
        dX = repmat(X1, [1, Numcoils]);
        dY = repmat(Y1, [1, Numcoils]);
        X = repmat(XCenter,[gridNum 1]);
        Y = repmat(YCenter,[gridNum 1]);
        W = repmat(W,[gridNum 1]);
        H = repmat(H,[gridNum 1]);
        % 重复线圈参数以匹配网格点扩展

        % 应用线圈大小调整到网格点
        dX = dX .* W;
        dY = dY .* H;

        % 应用旋转变换
        dX_rotated = dX .* cos(theta) - dY .* sin(theta);
        dY_rotated = dX .* sin(theta) + dY .* cos(theta);

        % 计算最终探测点坐标
        X = XCenter + dX_rotated;
        Y = YCenter + dY_rotated;

        % 将结果重新组织为行向量
        XX= reshape(X, [1, numel(X)]);
        YY = reshape(Y, [1, numel(Y)]);
    end

end


